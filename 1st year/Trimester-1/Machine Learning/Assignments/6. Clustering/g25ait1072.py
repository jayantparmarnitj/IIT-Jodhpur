# -*- coding: utf-8 -*-
"""g25ait1072_clustering.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1M0LQXKQeJIavOUlj_fZYohnF3M3-2Ntl

# Custom k-Means Implementation

## Import libraries
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from collections import defaultdict

"""## Load Dataset and data preparation"""

df = pd.read_csv("/content/sample_data/Mall_Customers.csv")

# Select columns for clustering
X = df[['Annual Income (k$)', 'Spending Score (1-100)']].values

# Standardize features: zero mean, unit variance
X_mean = X.mean(axis=0)
X_std = X.std(axis=0)
X_stdzd = (X - X_mean) / X_std

"""## 2. k-Means Implementation"""

class KMeans:
    def __init__(self, k, max_iters=100, tolerance=1e-4, init='random'):
        self.k = k
        self.max_iters = max_iters
        self.tolerance = tolerance
        self.init = init
        self.centroids = None

    def _euclidean(self, a, b):
        return np.sqrt(np.sum((a - b)**2, axis=1))

    def _initialize_centroids(self, X):
        np.random.seed(42)
        if self.init == 'random':
            idx = np.random.choice(len(X), self.k, replace=False)
            centroids = X[idx]
        elif self.init == 'kmeans++':
            centroids = []
            # choose first center randomly
            centroids.append(X[np.random.randint(len(X))])
            for _ in range(1, self.k):
                dist_sq = np.min(
                    np.array([self._euclidean(X, c) for c in centroids])**2, axis=0
                )
                prob = dist_sq / dist_sq.sum()
                next_idx = np.random.choice(len(X), p=prob)
                centroids.append(X[next_idx])
            centroids = np.array(centroids)
        else:
            raise ValueError("init must be 'random' or 'kmeans++'")
        return centroids

    def fit(self, X):
        self.centroids = self._initialize_centroids(X)
        for _ in range(self.max_iters):
            clusters = defaultdict(list)
            # Assignment step
            for x in X:
                idx = np.argmin(self._euclidean(self.centroids, x.reshape(1,-1)))
                clusters[idx].append(x)
            new_centroids = np.array([
                np.mean(clusters[i], axis=0) if clusters[i] else self.centroids[i]
                for i in range(self.k)
            ])
            # Check for convergence
            centroid_shift = np.linalg.norm(self.centroids - new_centroids, axis=1).mean()
            self.centroids = new_centroids
            if centroid_shift < self.tolerance:
                break
        # Save final labels for WCSS
        self.labels_ = np.array([np.argmin(self._euclidean(self.centroids, x.reshape(1,-1))) for x in X])
        return self

    def predict(self, X_test):
        return np.array([np.argmin(self._euclidean(self.centroids, x.reshape(1,-1))) for x in X_test])

    def wcss(self, X):

      total_wcss = 0.0  # Initialize total sum of squares

      # Loop over each cluster
      for cluster_index, centroid in enumerate(self.centroids):
          # Select all data points that belong to the current cluster
          cluster_points = X[self.labels_ == cluster_index]

          # Compute squared distances of these points from the cluster centroid
          squared_distances = (cluster_points - centroid) ** 2

          # Sum over all dimensions and all points in the cluster
          cluster_wcss = np.sum(squared_distances)

          # Add to the total WCSS
          total_wcss += cluster_wcss

      return total_wcss

"""### 3. Elbow Method for k selection

"""

wcss_vals = []
K_range = range(1, 11)
for k in K_range:
    model = KMeans(k=k)
    model.fit(X_stdzd)
    wcss_vals.append(model.wcss(X_stdzd))

### Create Table of k vs WCSS
elbow_table = pd.DataFrame({'k': list(K_range), 'WCSS': wcss_vals})
print(elbow_table)

"""### 4. Elbow Plot Visualization

"""

plt.figure(figsize=(7,5))
plt.plot(K_range, wcss_vals, marker='o')
plt.title("Elbow Plot: WCSS vs k")
plt.xlabel("Number of clusters (k)")
plt.ylabel("WCSS")
plt.xticks(K_range)
plt.grid(True)
plt.show()

"""## 5. Cluster Scatter Plot for Best k

"""

## 5. Cluster Scatter Plot for Best k
best_k = 5  # Use elbow plot to adjust value
final_model = KMeans(k=best_k)
final_model.fit(X_stdzd)
labels = final_model.labels_
centroids = final_model.centroids

plt.figure(figsize=(7,7))
for i in range(best_k):
    plt.scatter(X_stdzd[labels == i, 0], X_stdzd[labels == i, 1], label=f"Cluster {i}")
plt.scatter(centroids[:,0], centroids[:,1], color='blue', marker='X', s=200, label="Centroid")
plt.title("k-Means Clusters (k=5)")
plt.xlabel("Standardized Annual Income (k$)")
plt.ylabel("Standardized Spending Score (1-100)")
plt.legend()
plt.show()

"""## 6. Bonus: k-Means++ and Convergence Comparison

"""

wcss_random = []
wcss_plus = []
for k in K_range:
    m_random = KMeans(k=k, init='random')
    m_random.fit(X_stdzd)
    wcss_random.append(m_random.wcss(X_stdzd))

    m_plus = KMeans(k=k, init='kmeans++')
    m_plus.fit(X_stdzd)
    wcss_plus.append(m_plus.wcss(X_stdzd))

plt.figure(figsize=(7,5))
plt.plot(K_range, wcss_random, 'o-', label='Random Init')
plt.plot(K_range, wcss_plus, '*-', label='k-Means++')
plt.title("Elbow: WCSS for Random vs k-Means++ Init")
plt.xlabel("k")
plt.ylabel("WCSS")
plt.legend()
plt.show()

"""## 7. Bonus: Silhouette Score Implementation

"""

def silhouette_score(X, labels, k):
    N = X.shape[0]
    scores = []
    for idx in range(N):
        own_cluster = labels[idx]
        a = np.mean([np.linalg.norm(X[idx] - pt) for i, pt in enumerate(X) if labels[i] == own_cluster and i != idx])
        b = np.min([
            np.mean([np.linalg.norm(X[idx] - pt) for i, pt in enumerate(X) if labels[i]==other_k])
            for other_k in range(k) if other_k != own_cluster
        ])
        if b ==0 and a==0: scores.append(0) # edge case
        else: scores.append((b-a)/max(a,b))
    return np.mean(scores)

sil_scores = []
for k in range(2, 11): # Silhouette is undefined for k=1
    km = KMeans(k=k)
    km.fit(X_stdzd)
    sil = silhouette_score(X_stdzd, km.labels_, k)
    sil_scores.append(sil)

plt.figure(figsize=(7,5))
plt.plot(range(2,11), sil_scores, marker='o')
plt.title("Average Silhouette Score vs k")
plt.xlabel("k")
plt.ylabel("Average Silhouette Score")
plt.grid(True)
plt.show()
print(pd.DataFrame({'k': list(range(2,11)), 'Silhouette Score': sil_scores}))